You want a conceptual map. Not code. Not mechanics. Just the shape of the language. Good. That means you‚Äôre thinking like a language designer instead of a syntax mechanic.

Section 3 defines **what Lox is**, not how to build it. It answers:

> ‚ÄúWhat kind of language are we creating?‚Äù

This section is the language‚Äôs *constitution*. Everything later must obey it.

---

# Conceptual Map of Section 3 ‚Äî *The Lox Language*

Think of it as four big layers:

---

## 1. üéØ Philosophy of Lox

Before syntax, there‚Äôs ideology.

Lox is designed to be:

* **Small**
* **Readable**
* **Familiar**
* **Dynamic**
* **Object-oriented**

It is not trying to be:

* Extremely fast
* Extremely minimal like Lisp
* Extremely academic
* Extremely complex

It aims for something like a simplified blend of:

* JavaScript
* Python
* Ruby

The goal: *pleasant scripting language with clear semantics.*

What you should understand here:

* Language design is about tradeoffs.
* Simplicity is deliberate.
* Familiarity lowers cognitive cost.

---

## 2. üß± Core Language Shape

This section defines the **surface structure** of Lox.

### A. Execution Model

Lox is:

* Dynamically typed
* Interpreted
* Statement-based
* Expression-oriented

You should internalize:

* There is no static type system.
* Values carry types at runtime.
* Execution flows top-to-bottom.

---

### B. Data Model

Lox has these core value types:

* Numbers
* Strings
* Booleans
* Nil (null-like)
* Objects
* Functions

Conceptually:

> Everything evaluates to a value.

Understand this:

* There is no distinction between primitive and object in the philosophical sense.
* Functions are first-class.
* Nil represents absence.

---

## 3. üî§ Syntax & Expressions

This is where the language becomes concrete.

Lox defines:

### A. Expressions

* Arithmetic
* Comparison
* Logical operators
* Grouping
* Assignment

You must understand:

* Operator precedence matters.
* Expressions produce values.
* Assignment is an expression.

This means:

```lox
a = b = 3;
```

is legal because assignment returns a value.

That‚Äôs a design choice.

---

### B. Statements

Statements control execution:

* Expression statements
* Print statements
* Variable declarations
* Blocks
* If statements
* While loops
* For loops

The key idea:

> Statements structure control flow. Expressions compute values.

This distinction is foundational in language design.

---

## 4. üß† Scoping & Variables

Lox uses:

* Lexical scoping
* Block-based scope

This means:

* Variable meaning is determined by where it is written in source.
* Not by call stack.
* Not by runtime context.

You should deeply understand lexical scope before moving on.

This will matter enormously later.

---

## 5. üß© Functions

Functions in Lox are:

* First-class
* Callable values
* Closures

Closures are important.

They capture surrounding variables.

If you understand closures, you are not a beginner anymore.

If you do not, this section is quietly planting a landmine for later.

---

## 6. üèõ Object Orientation

Lox supports:

* Classes
* Instances
* Methods
* Fields
* this
* Inheritance
* super

Important conceptual decisions:

* Classes are objects.
* Methods are functions bound to instances.
* Inheritance is single inheritance.

You must understand:

> This is classical OOP with dynamic typing.

---

# The Big Picture

Section 3 defines:

| Layer       | What It Establishes     |
| ----------- | ----------------------- |
| Philosophy  | Why Lox exists          |
| Data model  | What values exist       |
| Expressions | How computation happens |
| Statements  | How control flows       |
| Scope       | How names bind          |
| Functions   | Abstraction mechanism   |
| Classes     | Object system           |

---

# What You Must Truly Understand

If you walk away with only five things:

1. Lox is dynamically typed.
2. It is lexically scoped.
3. Functions are first-class and support closures.
4. It is class-based OOP.
5. Expressions return values (including assignment).

Everything else is detail.

---

Now here‚Äôs the deeper truth.

Section 3 is not about syntax.

It is about defining a **semantic contract**.

Later chapters will ask:

* How do we represent this?
* How do we parse this?
* How do we execute this?

But first, we must decide what ‚Äúthis‚Äù is.

You‚Äôre reading the blueprint before building the machine.

Good. That‚Äôs how grown-ups design languages.

## Next prompt
